
@model SpeciesAssessment2021

@functions {

    private SpeciesAssessment2021MinMaxProbableIntervall GetQuantileForCriteria(string key)
    {
        switch (key)
        {
            case "A1":
                return Model.A1.QuantifiedReduction;
            case "A2":
                return Model.A2.QuantifiedReduction;
            case "A3":
                return Model.A3.QuantifiedReduction;
            case "A4":
                return Model.A4.QuantifiedReduction;
            case "B1":
                return Model.B1.Statistics;
            case "B2":
                return Model.B2.Statistics;
            case "BAii":
                return Model.BAii.Statistics;
            case "C":
                return Model.C.Statistics;
            case "C1":
                return Model.C1.Statistics;
            case "C2Ai":
                return Model.C2Ai.Statistics;
        }
        return null;
    }

}

@*
    TODO: IMPROVE AND MOVE LOGIC FROM VIEW. NOT CRITICAL, WILL NOT PRIORITIZE.

    This component takes in the json file of criteria and displays it
    It also takes in the unhandled criteriasummarized string and trasforms it
    into two useable dictionaries which are then matched to relevant places in the json.
*@

@{
    Dictionary<string, Dictionary<string, object>> parseDictNested(string json)
    {
        return Newtonsoft.Json.Linq.JObject.Parse(json).ToObject<Dictionary<string, Dictionary<string, object>>>();
    }

    Dictionary<string, object> parseDictObject(string json)
    {
        return Newtonsoft.Json.Linq.JObject.Parse(json).ToObject<Dictionary<string, object>>();
    }

    Dictionary<string, string> parseDictString(string json)
    {
        return Newtonsoft.Json.Linq.JObject.Parse(json).ToObject<Dictionary<string, string>>();
    }

    // Cast JSON to dictionary for easy iteration. Cant use those above as it's not a string...
    Dictionary<string, Dictionary<string, object>> criteria = ViewBag.kriterier.ToObject<Dictionary<string, Dictionary<string, object>>>();


    // Each criteria by letter is handled differently.
    string a = "", b = "", c = "", d = "";

    void placeCriteria(string criteria)
    {

        if (criteria.Contains("A"))
        {
            a = criteria;
        }
        else if (criteria.Contains("B"))
        {
            b = criteria;
        }
        else if (criteria.Contains("C"))
        {
            c = criteria;
        }
        else if (criteria.Contains("D"))
        {
            d = criteria;
        }

    }

    // Iterate the criteria string and place each separate criteria in its correct container.
    if (@Model.CriteriaSummarized.Contains(";"))
    {
        // SPLIT THE LIST AND LOOP THEM
        foreach (string crit in @Model.CriteriaSummarized.Split(";"))
        {
            placeCriteria(crit);
        }
    }
    else
    {
        placeCriteria(@Model.CriteriaSummarized);
    }


    // Sort criteria contents

    string subCriteria(string element, string bigstring)
    {
        return bigstring.Replace("+", ";" + element);
    }

    void hasKey(string key, Dictionary<string, object> field)
    {
        @if (field.ContainsKey(key))
        {
        <p class="@key">
            @field[key] 
        </p>
        }

    }

    a = subCriteria("A", a); // A CRITERIA - OPTIONS AND SUBCRITERIA ARE NOT SEPARATE ENTITIES
    c = subCriteria("C", c); // C CRITERIA - All options are only relevant for C2 - handle in code.
    d = subCriteria("D", d); // D CRITERIA: - ONLY subcriteria.

    // B CRITERIA - OPTIONS AND SUBCRITERIA ARE SEPARATE ENTITIES, options may contain sub-options

    string b_subcriteria = "";
    string b_options = "";

    b = subCriteria("B", b);
    if (b.Contains("B1"))
    {
        b_subcriteria += "B1;";
        b = b.Replace("B1", "");
    }
    if (b.Contains("B2"))
    {
        b_subcriteria += "B2";
        b = b.Replace("B2", "");
    }

    b = b.Replace("b", ";b");
    b = b.Replace("c", ";c");
    var b_distinctlist = b.Split(";").Distinct();
    b_options = string.Join(";", b_distinctlist);
    b = b_subcriteria + ";" + b_options;


    string handleCCriteria(string current_element, string key)
    {
        if (key == "C")
        {
            // THIS IS ONLY RELEVANT FOR C2
            current_element = current_element.Replace("a(i,ii)", "a(i)a(ii)");
            current_element = current_element.Replace(")", ");");
            current_element = current_element.Replace(" ", "");
        }
        else
        {
            current_element = current_element.Replace(",", ";");
        }
        return current_element;
    }


    string[] obtainSubCriteriaList(string[] splitlist, string k)
    {
        var current_element = "";
        @foreach (string element in splitlist)
        {
            if (element.Contains(k))// k = current criteria
            {
                current_element = element;
            }
        }
        current_element = current_element.Replace(k, ""); // remove main criteria, leaving nested subcriteria
        current_element = removeOuterParenthesis(current_element);
        current_element = handleCCriteria(current_element, k);
        return current_element.Split(";");
    }

    // The dictionaries used in the view <- two dicts made sense back when A was thought to have options as well. Now not as much

    var subcriteria = new Dictionary<string, string>(){
    {"A", a},
    {"B", b_subcriteria},
    {"C", c},
    {"D", d}
    };

    var options = new Dictionary<string, string>(){
    {"B", b_options},
    };

    // Functions relevant to string separation

    string inString(string element, string bigstring)
    {
        if (bigstring.Contains(element))
        {
            return "active";
        }
        return "inactive";
    }

    string inList(string element, string[] bigstring)
    {
        foreach (string el in bigstring)
        {
            if (bigstring.Contains(element))
            {
                return "active";
            }
        }
        return "inactive";
    }

    string removeOuterParenthesis(string wrapped)
    {
        if (wrapped.Length > 2)
        {
            if (wrapped.StartsWith("(") && wrapped.EndsWith(")"))
            {
                return wrapped.Substring(1, wrapped.Length - 2);
            }
        }
        return wrapped;
    }

    // FUNCTIONAL COMPONENTS BECAUSE LETS PRETEND THIS IS REACT.

    void iconChooser(string compare)
    {
        if (compare == "active")
        {
            <span class="material-icons" style="color:darkgreen">
                done
            </span>
        }
        else if (compare == "maybe")
        {
            <span class="material-icons">
                pause
            </span>
        }
        else
        {
            <span class="material-icons" style="color:darkred">
                close
            </span>
        }
    }

    void indicatordots(string unit, SpeciesAssessment2021MinMaxProbableIntervall quantile)
    {
        @if (unit == "%")
        {
            <span class="indicator_dot" style="right: @quantile.Max%">
                <span class="indicator_text max"> Max @quantile.Max@unit</span>
                <span class="dot_dot"></span>
            </span>
            <span class="indicator_dot" style="right: @quantile.Calculated%">
                <span class="indicator_text calc"> Calculated @quantile.Calculated@unit</span>
                <span class="dot_dot"></span>
            </span>
            @if (@quantile.Probable.Length > 0)
            {
                <span class="indicator_dot" style="right: @quantile.Probable%">
                    <span class="indicator_text prob">Probable @quantile.Probable@unit</span>
                    <span class="dot_dot"></span>
                </span>
            }
            <span class="indicator_dot" style="right: @quantile.Min%">
                <span class="indicator_text min"> Min @quantile.Min@unit</span>
                <span class="dot_dot"></span>
            </span>
        }
    }


    void mmpi(string value, SpeciesAssessment2021MinMaxProbableIntervall quantile)
    {

        var json_quantile = parseDictObject(value);
        string unit = json_quantile.ContainsKey("unit") ? json_quantile["unit"].ToString() : "";
        string comparator = json_quantile.ContainsKey("comparator") ? json_quantile["comparator"].ToString() : "";
        string min = @quantile.Min;
        string max = @quantile.Max;
        string estimated = "-";
        <div class="criteria_results">


            @if (quantile.Punktestimat == false) // true = default, thus may still include blank fields.
            {
                estimated = @quantile.Maxintervall + " - " + @quantile.Minintervall;
            }
            else
            {
                estimated = @quantile.Probable;
            }

            @if (json_quantile.ContainsKey("threshold"))
            {
                var thresholds = parseDictString(json_quantile["threshold"].ToString());

                <div class="category_graph LC">

                    <span>@{indicatordots(unit, quantile);}</span>
                    @{

                        int previous_threshold = 100;
                        int width = 0;
                        int flex = 1;
                    }

                    @foreach (var (cat, catval) in thresholds)
                    {
                        int n;
                        bool isNumeric = int.TryParse(catval, out n);
                        if (isNumeric)
                        {
                            if (unit == "%")
                            {
                                width = previous_threshold - n;
                            }
                            else
                            {
                                width = 20;
                                flex = n;
                            }
                        }
                        else
                        {
                            width = 20;
                        }
                        <div class="@cat category_graph_element" style="width:@width%;flex:@flex">
                            @cat
                            <br />
                            <span>@comparator@catval@unit</span>
                        </div>
                        previous_threshold = n;
                    }
                </div>
            }
            <p>
                Estimert verdi ligger på @quantile.Calculated @unit.
                Det antas en nedgang på mellom @min@unit og @max@unit@if (estimated.Length > 0)
                {<span>, som mest trolig ligger på @estimated @unit</span>}.
            </p>
        </div>

    }<!-- END OF FUNCTION-->
}<!-- END OF ALL-->


@if (!string.IsNullOrEmpty(Model.CriteriaSummarized) && (Model.Category.Contains("CR") || Model.Category.Contains("EN") ||
        Model.Category.Contains("VU") || Model.Category.Contains("NT")))
{
    <div class="page_section criteria">
        <div class="criteria_description">
            <h2>@ViewBag.glossary["criteria"]["tagline"]</h2>
            <p>@ViewBag.glossary["criteria"]["description"]</p>

            <h3>@ViewBag.glossary["criteria"]["subheading"]</h3>
            <p>@Model.CriteriaSummarized<br /></p>
            @*// TODO: FIX BUTTONS. MAKE URLS, make pretty, add link*@
            <button>Gå til ordliste</button>
            <button>Gå til metode</button>
            @*
                TODO: switch not working when moving up one level due to type difference.
                @Model.A1
                @Model.A1.ReductionBasedOn
                @Model.A1.QuantifiedReduction
                @Model.A2.PreliminaryCategory
            *@
        </div>

        <!-- MAIN CRITERIA -->
        @foreach (var (key, value) in criteria)
        {
            <div class="criteria_element @inString(key, @Model.CriteriaSummarized) listitem_criteria">

                @{ iconChooser(inString(key, Model.CriteriaSummarized)); }
                <div class="listitem_text_field">
                    <h4>@key -  @value["title"]</h4>
                    @{ hasKey("description", @value);}

                    <!-- SUB CRITERIA : obtain and reformat necessary data -->
                    @if (@value.ContainsKey("subcriteria"))
                    {
                        <div class="criteria_subcriteria">
                            @{
                                var thesubcriteria = parseDictNested(value["subcriteria"].ToString());
                            }
                            @foreach (var (k, v) in thesubcriteria)
                            {
                                <!-- ITERATE THROUGH ALL SUBCRITERIA -->
                                <div class=" @inString(k, subcriteria[key]) listitem_criteria">

                                    @{iconChooser(@inString(k, subcriteria[key]));}
                                    <div class="listitem_text_field">

                                        <h5>@k <span>@v["title"]</span></h5>
                                        @{ hasKey("description", v);}

                                        @{ // CALCULATIONS, NUMBERS AND ALL FUN THINGS
                                            var quantile = GetQuantileForCriteria(k);
                                            if (quantile != null)
                                            {
                                                mmpi(v["content"].ToString(), GetQuantileForCriteria(k));
                                            }
                                        }
                                        <!-- SUBCRITERIA SUBOPTIONS FOR A & C-CRITERIA && SUBOPTIONS FOR Ca2 -->
                                        @if (v.ContainsKey("subsub"))
                                        {
                                            string[] currentlist = obtainSubCriteriaList(subcriteria[key].Split(";"), k);
                                            var subdict = parseDictNested(@v["subsub"].ToString());
                                            @if (currentlist.Length > 0)
                                            {
                                                <div class="subsub_list">
                                                    <h6 class="subheading">Kunnskapsgrunnlag</h6>

                                                    @foreach (var (subkey, subval) in subdict)
                                                    {
                                                        <div class="@inList(subkey, currentlist) listitem_criteria">
                                                            @{ iconChooser(inList(subkey, currentlist)); }
                                                            <h6 class="listitem_text_field">
                                                                <b>@subkey</b>
                                                                <span>@subval["title"]</span>
                                                            </h6>
                                                        </div>
                                                    }
                                                </div>
                                            }
                                        }
                                    </div>
                                </div>
                            }
                        </div>
                    }

                    <!-- OPTIONS-->
                    @if (@value.ContainsKey("options"))
                    {
                        var newDictionary = parseDictNested(value["options"].ToString());
                        <div class="criteria_options">
                            <h5 class="subheading"> Underkriterier </h5>
                            @{ hasKey("options_description", @value);}
                            @foreach (var (k, v) in newDictionary)
                            {
                                <div class="listitem_criteria @inString(k, options[key]) ">
                                    @{ iconChooser(inString(k, options[key])); }
                                    <div class="listitem_text_field">
                                        <h5>@k. <span>@v["title"]</span></h5>
                                        @{ hasKey("description", v);}
                                        @if (v.ContainsKey("sub"))
                                        {
                                            <div class="subsub_list">
                                                @{
                                                    var currentlist = options[key].Split(";");
                                                    var current_element = "";
                                                    foreach (string element in currentlist)
                                                    {
                                                        if (element.Contains(k))
                                                        {
                                                            current_element = element;
                                                        }
                                                    }
                                                    current_element = current_element.Replace(k, "");
                                                    current_element = removeOuterParenthesis(current_element);
                                                    var clean_list = current_element.Split(",");
                                                    var subdict = parseDictNested(@v["sub"].ToString());
                                                }
                                                @foreach (var (subkey, subvalue) in subdict)
                                                {
                                                    <div class="listitem_criteria @inList(subkey, clean_list)">
                                                        @{ iconChooser(inList(subkey, clean_list)); }
                                                        <h6 class="listitem_text_field">
                                                            <span>@subkey </span>
                                                            <span>@subvalue["title"]</span>
                                                        </h6>
                                                    </div>
                                                }
                                            </div>
                                        }
                                    </div>
                                </div>
                            }
                        </div>
                    }<!-- END OPTIONS-->
                </div>
            </div>
        }
    </div>
}
